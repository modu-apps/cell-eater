{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts", "../src/constants.ts", "../src/entities.ts", "../src/systems.ts", "../src/render.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "import { dSqrt, dRandom } from 'modu-engine';\n/**\n * Cell Eater - Agar.io style multiplayer game\n *\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\n */\n\nimport * as modu from 'modu-engine';\nimport { WORLD_WIDTH, WORLD_HEIGHT, FOOD_COUNT } from './constants';\nimport { defineEntities } from './entities';\nimport {\n    setupSystems,\n    setupCollisions,\n    spawnFood,\n    spawnCell,\n    getPlayerCells,\n    cellMergeFrame,\n} from './systems';\nimport { createRenderer } from './render';\n\n// Game state\nlet game: modu.Game;\nlet renderer: modu.Simple2DRenderer;\nlet physics: modu.Physics2DSystem;\nlet input: modu.InputPlugin;\nlet cameraSystem: modu.CameraSystem;\nlet cameraEntity: modu.Entity;\n\nlet canvas: HTMLCanvasElement;\nlet minimapCanvas: HTMLCanvasElement;\nlet sizeDisplay: HTMLElement;\nlet WIDTH: number;\nlet HEIGHT: number;\n\nlet mouseX: number;\nlet mouseY: number;\n\nfunction getLocalClientId(): number | null {\n    const clientId = game.localClientId;\n    if (!clientId || typeof clientId !== 'string') return null;\n    return game.internClientId(clientId);\n}\n\nfunction setupInput(getCameraEntity: () => modu.Entity): void {\n    mouseX = WIDTH / 2;\n    mouseY = HEIGHT / 2;\n\n    canvas.addEventListener('mousemove', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        mouseX = e.clientX - rect.left;\n        mouseY = e.clientY - rect.top;\n    });\n\n    input.action('target', {\n        type: 'vector',\n        bindings: [() => {\n            // Convert screen to world coordinates\n            const cam = getCameraEntity().get(modu.Camera2D);\n            const worldX = (mouseX - WIDTH / 2) / cam.zoom + cam.x;\n            const worldY = (mouseY - HEIGHT / 2) / cam.zoom + cam.y;\n            return { x: worldX, y: worldY };\n        }]\n    });\n\n    input.action('split', {\n        type: 'button',\n        bindings: ['key: ']\n    });\n}\n\nexport function initGame(): void {\n    canvas = document.getElementById('game') as HTMLCanvasElement;\n    minimapCanvas = document.getElementById('minimap') as HTMLCanvasElement;\n    sizeDisplay = document.getElementById('size-display')!;\n    WIDTH = canvas.width;\n    HEIGHT = canvas.height;\n\n    game = modu.createGame();\n    renderer = game.addPlugin(modu.Simple2DRenderer, canvas);\n    physics = game.addPlugin(modu.Physics2DSystem, { gravity: { x: 0, y: 0 } });\n    input = game.addPlugin(modu.InputPlugin, canvas);\n    cameraSystem = game.addPlugin(modu.CameraSystem);\n\n    // Expose for debugging\n    (window as any).game = game;\n\n    defineEntities(game);\n    setupCollisions(game, physics);\n    setupSystems(game);\n\n    // Create camera entity and set it on renderer\n    cameraEntity = game.spawn('camera');\n    const cam = cameraEntity.get(modu.Camera2D);\n    cam.x = WORLD_WIDTH / 2;\n    cam.y = WORLD_HEIGHT / 2;\n    renderer.camera = cameraEntity;\n\n    // Helper to ensure camera entity exists (survives snapshot loads)\n    function ensureCameraEntity(): modu.Entity {\n        if (!cameraEntity || cameraEntity.destroyed || !cameraEntity.has(modu.Camera2D)) {\n            cameraEntity = game.spawn('camera');\n            const cam = cameraEntity.get(modu.Camera2D);\n            cam.x = WORLD_WIDTH / 2;\n            cam.y = WORLD_HEIGHT / 2;\n            renderer.camera = cameraEntity;\n        }\n        return cameraEntity;\n    }\n\n    setupInput(ensureCameraEntity);\n\n    renderer.render = createRenderer(\n        game,\n        renderer,\n        ensureCameraEntity,  // Pass getter function\n        canvas,\n        minimapCanvas,\n        sizeDisplay,\n        getLocalClientId\n    );\n\n    game.connect('cell-eater-ecs', {\n        onRoomCreate() {\n            console.log('[cell-eater] onRoomCreate');\n            for (let i = 0; i < FOOD_COUNT; i++) spawnFood(game);\n        },\n        onConnect(clientId: string) {\n            console.log('[cell-eater] onConnect:', clientId);\n            spawnCell(game, clientId);\n\n            if (clientId === game.localClientId) {\n                const player = game.getEntityByClientId(clientId);\n                if (player) {\n                    const t = player.get(modu.Transform2D);\n                    const cam = ensureCameraEntity().get(modu.Camera2D);\n                    cam.x = t.x;\n                    cam.y = t.y;\n                }\n            }\n        },\n        onDisconnect(clientId: string) {\n            console.log('[cell-eater] onDisconnect:', clientId);\n            const internedId = game.internClientId(clientId);\n            for (const cell of getPlayerCells(game, internedId)) {\n                cell.destroy();\n                cellMergeFrame.delete(cell.id);\n            }\n        }\n    });\n\n    modu.enableDebugUI(game);\n}\n\n// Auto-init when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initGame);\n} else {\n    initGame();\n}\n", "/**\n * Cell Eater - Game Constants\n */\n\n// World dimensions\nexport const WORLD_WIDTH = 6000;\nexport const WORLD_HEIGHT = 6000;\n\n// Zoom settings\nexport const BASE_ZOOM = 1.0;\nexport const MIN_ZOOM = 0.35;\nexport const ZOOM_SCALE_FACTOR = 0.004;\n\n// Movement\nexport const SPEED = 200;\n\n// Cell sizing\nexport const INITIAL_RADIUS = 20;\nexport const MAX_RADIUS = 200;\n\n// Eating mechanics\nexport const EAT_RATIO = 1.2;\nexport const FOOD_GROW = 0.05;\nexport const PLAYER_GROW = 0.3;\n\n// Food spawning\nexport const FOOD_COUNT = 800;\nexport const MAX_FOOD = 1600;\nexport const FOOD_SPAWN_CHANCE = 0.15;\n\n// Split mechanics\nexport const MIN_SPLIT_RADIUS = 15;\nexport const SPLIT_IMPULSE = 800;\nexport const SPLIT_DAMPING = 0.03;\nexport const MAX_CELLS_PER_PLAYER = 16;\nexport const MERGE_DELAY_FRAMES = 600;\nexport const MERGE_THRESHOLD = 0.5;\n\n// Physics\nexport const REPULSION_FACTOR = 0.3;\nexport const REPULSION_BASE = 1;\nexport const MOVE_DEADZONE = 5;\n\n// Color palette\nexport const COLORS = [\n    '#ff6b6b', '#ff8e72', '#ffa94d', '#ffd43b', '#a9e34b', '#69db7c',\n    '#38d9a9', '#3bc9db', '#4dabf7', '#748ffc', '#9775fa', '#da77f2',\n    '#f783ac', '#e64980', '#d6336c', '#c2255c', '#ff4500', '#32cd32',\n    '#1e90ff', '#ff1493', '#00ced1', '#ffa500', '#9400d3', '#00ff7f'\n];\n", "/**\r\n * Cell Eater - Entity Definitions\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { INITIAL_RADIUS } from './constants';\r\n\r\nexport function defineEntities(game: modu.Game): void {\r\n    game.defineEntity('cell')\r\n        .with(modu.Transform2D)\r\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, layer: 1 })\r\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, bodyType: modu.BODY_KINEMATIC })\r\n        .with(modu.Player)\r\n        .register();\r\n\r\n    game.defineEntity('food')\r\n        .with(modu.Transform2D)\r\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: 8, layer: 0 })\r\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: 8, bodyType: modu.BODY_STATIC })\r\n        .register();\r\n\r\n    // Camera entity - client-only, excluded from snapshots entirely\r\n    game.defineEntity('camera')\r\n        .with(modu.Camera2D, { smoothing: 0.15 })\r\n        .syncNone()\r\n        .register();\r\n}\r\n", "import { dSqrt, dRandom } from 'modu-engine';\n/**\n * Cell Eater - Game Systems\n */\n\nimport * as modu from 'modu-engine';\nimport { SpawnCellOptions } from './types';\nimport {\n    WORLD_WIDTH,\n    WORLD_HEIGHT,\n    SPEED,\n    INITIAL_RADIUS,\n    MAX_RADIUS,\n    EAT_RATIO,\n    FOOD_GROW,\n    PLAYER_GROW,\n    MAX_FOOD,\n    FOOD_SPAWN_CHANCE,\n    MIN_SPLIT_RADIUS,\n    MAX_CELLS_PER_PLAYER,\n    MERGE_DELAY_FRAMES,\n    MERGE_THRESHOLD,\n    SPLIT_IMPULSE,\n    SPLIT_DAMPING,\n    REPULSION_FACTOR,\n    REPULSION_BASE,\n    MOVE_DEADZONE,\n    COLORS,\n} from './constants';\n\n// Track merge eligibility\nexport const cellMergeFrame = new Map<number, number>();\n\n// Helper: Get client ID string for deterministic sorting\nfunction getClientIdStr(game: modu.Game, numericId: number): string {\n    return game.getClientIdString(numericId) || '';\n}\n\n// Helper: Compare strings for deterministic sorting\nfunction compareStrings(a: string, b: string): number {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n}\n\n// Helper: Group cells by player, sorted deterministically\nfunction getPlayerCellsGrouped(game: modu.Game): Map<number, modu.Entity[]> {\n    const playerCells = new Map<number, modu.Entity[]>();\n    const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\n\n    for (const cell of allCells) {\n        if (cell.destroyed) continue;\n        const clientId = cell.get(modu.Player).clientId;\n        if (clientId === undefined || clientId === null) continue;\n        if (!playerCells.has(clientId)) playerCells.set(clientId, []);\n        playerCells.get(clientId)!.push(cell);\n    }\n\n    return playerCells;\n}\n\n// Helper: Get sorted player entries for deterministic iteration\nfunction getSortedPlayers(game: modu.Game, playerCells: Map<number, modu.Entity[]>): [number, modu.Entity[]][] {\n    return [...playerCells.entries()].sort((a, b) =>\n        compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\n    );\n}\n\nexport function getPlayerCells(game: modu.Game, clientId: number): modu.Entity[] {\n    const cells: modu.Entity[] = [];\n    for (const cell of game.query('cell')) {\n        if (cell.get(modu.Player).clientId === clientId && !cell.destroyed) {\n            cells.push(cell);\n        }\n    }\n    return cells;\n}\n\nexport function spawnFood(game: modu.Game): void {\n    const colorStr = COLORS[(dRandom() * COLORS.length) | 0];\n    const color = game.internString('color', colorStr);\n    game.spawn('food', {\n        x: 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0,\n        y: 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0,\n        color\n    });\n}\n\nexport function spawnCell(game: modu.Game, clientId: string, options: SpawnCellOptions = {}): modu.Entity {\n    const colorStr = options.color || COLORS[(dRandom() * COLORS.length) | 0];\n    const color = game.internString('color', colorStr);\n    const radius = options.radius || INITIAL_RADIUS;\n\n    const entity = game.spawn('cell', {\n        x: options.x ?? (100 + (dRandom() * (WORLD_WIDTH - 200)) | 0),\n        y: options.y ?? (100 + (dRandom() * (WORLD_HEIGHT - 200)) | 0),\n        clientId,\n        color\n    });\n\n    if (options.radius) {\n        const sprite = entity.get(modu.Sprite);\n        const body = entity.get(modu.Body2D);\n        sprite.radius = radius;\n        body.radius = radius;\n    }\n\n    if (options.vx !== undefined || options.vy !== undefined) {\n        const body = entity.get(modu.Body2D);\n        body.vx = options.vx || 0;\n        body.vy = options.vy || 0;\n    }\n\n    return entity;\n}\n\nexport function setupSystems(game: modu.Game): void {\n    // Movement system with integrated repulsion\n    game.addSystem(() => {\n        const playerCells = getPlayerCellsGrouped(game);\n        const sortedPlayers = getSortedPlayers(game, playerCells);\n\n        // Calculate repulsion forces between sibling cells\n        const repulsion = new Map<number, { vx: number; vy: number }>();\n\n        for (const [, siblings] of sortedPlayers) {\n            for (const cell of siblings) {\n                repulsion.set(cell.id, { vx: 0, vy: 0 });\n            }\n\n            if (siblings.length < 2) continue;\n\n            for (let i = 0; i < siblings.length; i++) {\n                const cellA = siblings[i];\n                const tA = cellA.get(modu.Transform2D);\n                const sA = cellA.get(modu.Sprite);\n\n                for (let j = i + 1; j < siblings.length; j++) {\n                    const cellB = siblings[j];\n                    const tB = cellB.get(modu.Transform2D);\n                    const sB = cellB.get(modu.Sprite);\n\n                    const dx = tA.x - tB.x;\n                    const dy = tA.y - tB.y;\n                    const distSq = dx * dx + dy * dy;\n                    const minDist = sA.radius + sB.radius;\n                    const minDistSq = minDist * minDist;\n\n                    if (distSq < minDistSq && distSq > 1) {\n                        const dist = dSqrt(distSq) || 1;\n                        const overlap = minDist - dist;\n                        const pushForce = (overlap * REPULSION_FACTOR) + REPULSION_BASE;\n                        const nx = dx / dist;\n                        const ny = dy / dist;\n\n                        const repA = repulsion.get(cellA.id)!;\n                        const repB = repulsion.get(cellB.id)!;\n                        repA.vx += nx * pushForce;\n                        repA.vy += ny * pushForce;\n                        repB.vx -= nx * pushForce;\n                        repB.vy -= ny * pushForce;\n                    }\n                }\n            }\n        }\n\n        // Apply movement based on input\n        for (const [clientId, cells] of sortedPlayers) {\n            const playerInput = game.world.getInput(clientId);\n\n            for (const cell of cells) {\n                const sprite = cell.get(modu.Sprite);\n                const transform = cell.get(modu.Transform2D);\n                const body = cell.get(modu.Body2D);\n\n                let vx = 0, vy = 0;\n\n                if (playerInput?.target) {\n                    const tx = playerInput.target.x;\n                    const ty = playerInput.target.y;\n\n                    if (isFinite(tx) && isFinite(ty)) {\n                        const dx = tx - transform.x;\n                        const dy = ty - transform.y;\n                        const dist = dSqrt(dx * dx + dy * dy);\n\n                        if (dist > MOVE_DEADZONE) {\n                            vx = (dx / dist) * SPEED;\n                            vy = (dy / dist) * SPEED;\n                        }\n                    }\n                }\n\n                // Add repulsion from sibling cells\n                const rep = repulsion.get(cell.id);\n                if (rep) {\n                    vx += rep.vx;\n                    vy += rep.vy;\n                }\n\n                cell.setVelocity(vx, vy);\n\n                // Clamp to world bounds\n                const r = sprite.radius;\n                transform.x = Math.max(r, Math.min(WORLD_WIDTH - r, transform.x));\n                transform.y = Math.max(r, Math.min(WORLD_HEIGHT - r, transform.y));\n            }\n        }\n    }, { phase: 'update' });\n\n    // Food spawning system\n    game.addSystem(() => {\n        const shouldSpawn = dRandom() < FOOD_SPAWN_CHANCE;\n        if (shouldSpawn && game.getEntitiesByType('food').length < MAX_FOOD) {\n            spawnFood(game);\n        }\n    }, { phase: 'update' });\n\n    // Split system\n    game.addSystem(() => {\n        const playerCells = getPlayerCellsGrouped(game);\n        const sortedPlayers = getSortedPlayers(game, playerCells);\n\n        for (const [clientId, cells] of sortedPlayers) {\n            const playerInput = game.world.getInput(clientId);\n\n            if (!playerInput?.split || !playerInput?.target) continue;\n            if (cells.length >= MAX_CELLS_PER_PLAYER) continue;\n\n            const cellsToSplit = cells\n                .filter(c => c.get(modu.Sprite).radius >= MIN_SPLIT_RADIUS)\n                .slice(0, MAX_CELLS_PER_PLAYER - cells.length);\n\n            for (const cell of cellsToSplit) {\n                const t = cell.get(modu.Transform2D);\n                const s = cell.get(modu.Sprite);\n                const b = cell.get(modu.Body2D);\n\n                // Direction to cursor\n                const dx = playerInput.target.x - t.x;\n                const dy = playerInput.target.y - t.y;\n                const len = dSqrt(dx * dx + dy * dy) || 1;\n\n                // Halve radius (area split in half)\n                const r = s.radius / Math.SQRT2;\n                s.radius = r;\n                b.radius = r;\n\n                const clientIdStr = game.getClientIdString(clientId);\n                if (!clientIdStr) continue;\n\n                // Spawn new cell\n                const newCell = spawnCell(game, clientIdStr, {\n                    x: t.x,\n                    y: t.y,\n                    radius: r,\n                    color: game.getString('color', s.color)\n                });\n\n                // Apply impulse towards cursor\n                const newBody = newCell.get(modu.Body2D);\n                newBody.impulseX = (dx / len) * SPLIT_IMPULSE;\n                newBody.impulseY = (dy / len) * SPLIT_IMPULSE;\n                newBody.damping = SPLIT_DAMPING;\n\n                // Track merge timing\n                const mergeFrame = game.world.frame + MERGE_DELAY_FRAMES;\n                cellMergeFrame.set(cell.id, mergeFrame);\n                cellMergeFrame.set(newCell.id, mergeFrame);\n            }\n        }\n    }, { phase: 'update' });\n\n    // Merge system\n    game.addSystem(() => {\n        const currentFrame = game.world.frame;\n        const playerCells = getPlayerCellsGrouped(game);\n        const sortedPlayers = getSortedPlayers(game, playerCells);\n\n        for (const [, cells] of sortedPlayers) {\n            if (cells.length < 2) continue;\n\n            // Sort by radius (largest first) for deterministic merge order\n            cells.sort((a, b) => {\n                const radiusDiff = b.get(modu.Sprite).radius - a.get(modu.Sprite).radius;\n                return radiusDiff !== 0 ? radiusDiff : a.id - b.id;\n            });\n\n            for (let i = 0; i < cells.length; i++) {\n                const cellA = cells[i];\n                if (cellA.destroyed) continue;\n\n                const tA = cellA.get(modu.Transform2D);\n                const sA = cellA.get(modu.Sprite);\n\n                for (let j = i + 1; j < cells.length; j++) {\n                    const cellB = cells[j];\n                    if (cellB.destroyed) continue;\n\n                    // Check merge cooldown\n                    const mergeFrameA = cellMergeFrame.get(cellA.id) || 0;\n                    const mergeFrameB = cellMergeFrame.get(cellB.id) || 0;\n                    if (currentFrame < mergeFrameA || currentFrame < mergeFrameB) continue;\n\n                    const tB = cellB.get(modu.Transform2D);\n                    const sB = cellB.get(modu.Sprite);\n\n                    const dx = tA.x - tB.x;\n                    const dy = tA.y - tB.y;\n                    const dist = dSqrt(dx * dx + dy * dy);\n                    const mergeThreshold = (sA.radius + sB.radius) * MERGE_THRESHOLD;\n\n                    if (dist < mergeThreshold) {\n                        // Merge: combine areas\n                        const areaA = sA.radius * sA.radius;\n                        const areaB = sB.radius * sB.radius;\n                        const newRadius = Math.min(dSqrt(areaA + areaB), MAX_RADIUS);\n\n                        sA.radius = newRadius;\n                        cellA.get(modu.Body2D).radius = newRadius;\n                        cellB.destroy();\n                        cellMergeFrame.delete(cellB.id);\n                    }\n                }\n            }\n        }\n    }, { phase: 'update' });\n}\n\nexport function setupCollisions(game: modu.Game, physics: modu.Physics2DSystem): void {\n    // Cell eats food\n    physics.onCollision('cell', 'food', (cell, food) => {\n        if (food.destroyed) return;\n        const sprite = cell.get(modu.Sprite);\n        const foodSprite = food.get(modu.Sprite);\n        sprite.radius = Math.min(sprite.radius + foodSprite.radius * FOOD_GROW, MAX_RADIUS);\n        cell.get(modu.Body2D).radius = sprite.radius;\n        food.destroy();\n    });\n\n    // Cell eats smaller cell (different players only)\n    physics.onCollision('cell', 'cell', (cellA, cellB) => {\n        if (cellA.get(modu.Player).clientId === cellB.get(modu.Player).clientId) return;\n\n        const eaterSprite = cellA.get(modu.Sprite);\n        const preySprite = cellB.get(modu.Sprite);\n        if (eaterSprite.radius > preySprite.radius * EAT_RATIO) {\n            eaterSprite.radius = Math.min(eaterSprite.radius + preySprite.radius * PLAYER_GROW, MAX_RADIUS);\n            cellA.get(modu.Body2D).radius = eaterSprite.radius;\n            cellB.destroy();\n            cellMergeFrame.delete(cellB.id);\n        }\n    });\n}\n", "/**\r\n * Cell Eater - Rendering & Camera\r\n */\r\n\r\nimport * as modu from 'modu-engine';\r\nimport { getPlayerCells } from './systems';\r\nimport {\r\n    WORLD_WIDTH,\r\n    WORLD_HEIGHT,\r\n    BASE_ZOOM,\r\n    MIN_ZOOM,\r\n    ZOOM_SCALE_FACTOR,\r\n    INITIAL_RADIUS,\r\n} from './constants';\r\n\r\nexport function lightenColor(hex: string, percent: number): string {\r\n    const num = parseInt(hex.slice(1), 16);\r\n    const r = Math.min(255, (num >> 16) + percent);\r\n    const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);\r\n    const b = Math.min(255, (num & 0x0000FF) + percent);\r\n    return `rgb(${r},${g},${b})`;\r\n}\r\n\r\nexport function darkenColor(hex: string, percent: number): string {\r\n    const num = parseInt(hex.slice(1), 16);\r\n    const r = Math.max(0, (num >> 16) - percent);\r\n    const g = Math.max(0, ((num >> 8) & 0x00FF) - percent);\r\n    const b = Math.max(0, (num & 0x0000FF) - percent);\r\n    return `rgb(${r},${g},${b})`;\r\n}\r\n\r\nexport function worldToScreen(\r\n    worldX: number,\r\n    worldY: number,\r\n    camX: number,\r\n    camY: number,\r\n    camZoom: number,\r\n    WIDTH: number,\r\n    HEIGHT: number\r\n): { x: number; y: number } {\r\n    return {\r\n        x: (worldX - camX) * camZoom + WIDTH / 2,\r\n        y: (worldY - camY) * camZoom + HEIGHT / 2\r\n    };\r\n}\r\n\r\nexport function updateCamera(\r\n    game: modu.Game,\r\n    cameraEntity: modu.Entity,\r\n    getLocalClientId: () => number | null\r\n): void {\r\n    const localId = getLocalClientId();\r\n    if (localId === null) return;\r\n\r\n    const cells = getPlayerCells(game, localId);\r\n    if (cells.length === 0) return;\r\n\r\n    const camera = cameraEntity.get(modu.Camera2D);\r\n\r\n    let totalSize = 0;\r\n    let totalArea = 0;\r\n    let centerX = 0;\r\n    let centerY = 0;\r\n\r\n    for (const cell of cells) {\r\n        const transform = cell.get(modu.Transform2D);\r\n        const sprite = cell.get(modu.Sprite);\r\n        const area = sprite.radius * sprite.radius;\r\n\r\n        centerX += transform.x * area;\r\n        centerY += transform.y * area;\r\n        totalArea += area;\r\n        totalSize += sprite.radius;\r\n    }\r\n\r\n    if (totalArea > 0) {\r\n        centerX /= totalArea;\r\n        centerY /= totalArea;\r\n\r\n        camera.x += (centerX - camera.x) * camera.smoothing;\r\n        camera.y += (centerY - camera.y) * camera.smoothing;\r\n\r\n        camera.targetZoom = Math.max(MIN_ZOOM, BASE_ZOOM - (totalSize - INITIAL_RADIUS) * ZOOM_SCALE_FACTOR);\r\n        camera.zoom += (camera.targetZoom - camera.zoom) * camera.smoothing;\r\n    }\r\n}\r\n\r\nexport function createRenderer(\r\n    game: modu.Game,\r\n    renderer: modu.Simple2DRenderer,\r\n    getCameraEntity: () => modu.Entity,\r\n    canvas: HTMLCanvasElement,\r\n    minimapCanvas: HTMLCanvasElement,\r\n    sizeDisplay: HTMLElement,\r\n    getLocalClientId: () => number | null\r\n): () => void {\r\n    const ctx = renderer.context;\r\n    const minimapCtx = minimapCanvas.getContext('2d')!;\r\n    const WIDTH = canvas.width;\r\n    const HEIGHT = canvas.height;\r\n\r\n    function renderMinimap(): void {\r\n        const cameraEntity = getCameraEntity();\r\n        const camera = cameraEntity.get(modu.Camera2D);\r\n        const mmW = minimapCanvas.width;\r\n        const mmH = minimapCanvas.height;\r\n        const scaleX = mmW / WORLD_WIDTH;\r\n        const scaleY = mmH / WORLD_HEIGHT;\r\n\r\n        minimapCtx.fillStyle = 'rgba(17, 17, 17, 0.9)';\r\n        minimapCtx.fillRect(0, 0, mmW, mmH);\r\n\r\n        minimapCtx.strokeStyle = '#333';\r\n        minimapCtx.lineWidth = 1;\r\n        minimapCtx.strokeRect(0, 0, mmW, mmH);\r\n\r\n        for (const entity of game.getAllEntities()) {\r\n            if (entity.destroyed) continue;\r\n            try {\r\n                const sprite = entity.get(modu.Sprite);\r\n                if (!sprite || !sprite.visible) continue;\r\n\r\n                const transform = entity.get(modu.Transform2D);\r\n                const x = transform.x * scaleX;\r\n                const y = transform.y * scaleY;\r\n\r\n                const isFood = sprite.layer === 0;\r\n                const radius = isFood ? 1 : Math.max(3, sprite.radius * scaleX * 1.5);\r\n\r\n                const colorStr = game.getString('color', sprite.color) || '#fff';\r\n                minimapCtx.fillStyle = isFood ? 'rgba(255,255,255,0.3)' : colorStr;\r\n                minimapCtx.beginPath();\r\n                minimapCtx.arc(x, y, radius, 0, Math.PI * 2);\r\n                minimapCtx.fill();\r\n            } catch {}\r\n        }\r\n\r\n        const viewLeft = (camera.x - WIDTH / 2 / camera.zoom) * scaleX;\r\n        const viewTop = (camera.y - HEIGHT / 2 / camera.zoom) * scaleY;\r\n        const viewWidth = (WIDTH / camera.zoom) * scaleX;\r\n        const viewHeight = (HEIGHT / camera.zoom) * scaleY;\r\n\r\n        minimapCtx.strokeStyle = '#fff';\r\n        minimapCtx.lineWidth = 1;\r\n        minimapCtx.strokeRect(viewLeft, viewTop, viewWidth, viewHeight);\r\n\r\n        const localId = getLocalClientId();\r\n        if (localId !== null) {\r\n            const cells = getPlayerCells(game, localId);\r\n            for (const cell of cells) {\r\n                if (cell.destroyed) continue;\r\n                const transform = cell.get(modu.Transform2D);\r\n                const x = transform.x * scaleX;\r\n                const y = transform.y * scaleY;\r\n\r\n                minimapCtx.strokeStyle = '#fff';\r\n                minimapCtx.lineWidth = 2;\r\n                minimapCtx.beginPath();\r\n                minimapCtx.arc(x, y, 5, 0, Math.PI * 2);\r\n                minimapCtx.stroke();\r\n            }\r\n        }\r\n    }\r\n\r\n    return function renderWithCamera(): void {\r\n        const cameraEntity = getCameraEntity();\r\n        const alpha = game.getRenderAlpha();\r\n        const camera = cameraEntity.get(modu.Camera2D);\r\n\r\n        updateCamera(game, cameraEntity, getLocalClientId);\r\n\r\n        // Use camera position directly (matches input coordinate conversion)\r\n        const camX = camera.x;\r\n        const camY = camera.y;\r\n\r\n        // Clear canvas\r\n        ctx.fillStyle = '#f2f2f2';\r\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\r\n\r\n        ctx.save();\r\n        ctx.translate(WIDTH / 2, HEIGHT / 2);\r\n        ctx.scale(camera.zoom, camera.zoom);\r\n        ctx.translate(-camX, -camY);\r\n\r\n        // Draw grid\r\n        ctx.strokeStyle = '#e0e0e0';\r\n        ctx.lineWidth = 1 / camera.zoom;\r\n        const gridSize = 100;\r\n        const startX = Math.floor((camX - WIDTH / 2 / camera.zoom) / gridSize) * gridSize;\r\n        const startY = Math.floor((camY - HEIGHT / 2 / camera.zoom) / gridSize) * gridSize;\r\n        const endX = camX + WIDTH / 2 / camera.zoom;\r\n        const endY = camY + HEIGHT / 2 / camera.zoom;\r\n\r\n        for (let x = startX; x <= endX; x += gridSize) {\r\n            if (x >= 0 && x <= WORLD_WIDTH) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(x, Math.max(0, startY));\r\n                ctx.lineTo(x, Math.min(WORLD_HEIGHT, endY));\r\n                ctx.stroke();\r\n            }\r\n        }\r\n        for (let y = startY; y <= endY; y += gridSize) {\r\n            if (y >= 0 && y <= WORLD_HEIGHT) {\r\n                ctx.beginPath();\r\n                ctx.moveTo(Math.max(0, startX), y);\r\n                ctx.lineTo(Math.min(WORLD_WIDTH, endX), y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw world boundary\r\n        ctx.strokeStyle = '#ccc';\r\n        ctx.lineWidth = 4 / camera.zoom;\r\n        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\r\n\r\n        // Collect and sort entities by layer\r\n        const entities: { entity: modu.Entity; layer: number }[] = [];\r\n        for (const entity of game.getAllEntities()) {\r\n            if (entity.destroyed) continue;\r\n            try {\r\n                const sprite = entity.get(modu.Sprite);\r\n                if (sprite && sprite.visible) {\r\n                    entity.interpolate(alpha);\r\n                    entities.push({ entity, layer: sprite.layer });\r\n                }\r\n            } catch {}\r\n        }\r\n        entities.sort((a, b) => a.layer - b.layer);\r\n\r\n        // Draw entities\r\n        for (const { entity } of entities) {\r\n            const sprite = entity.get(modu.Sprite);\r\n            const x = entity.render.interpX + sprite.offsetX;\r\n            const y = entity.render.interpY + sprite.offsetY;\r\n\r\n            const screenPos = worldToScreen(x, y, camX, camY, camera.zoom, WIDTH, HEIGHT);\r\n            const screenRadius = sprite.radius * camera.zoom;\r\n            if (screenPos.x + screenRadius < 0 || screenPos.x - screenRadius > WIDTH ||\r\n                screenPos.y + screenRadius < 0 || screenPos.y - screenRadius > HEIGHT) {\r\n                continue;\r\n            }\r\n\r\n            const colorStr = game.getString('color', sprite.color) || '#fff';\r\n\r\n            if (sprite.shape === modu.SHAPE_CIRCLE) {\r\n                const r = sprite.radius;\r\n                const isCell = sprite.layer === 1;\r\n\r\n                if (isCell && r > 10) {\r\n                    const gradient = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);\r\n                    gradient.addColorStop(0, lightenColor(colorStr, 40));\r\n                    gradient.addColorStop(0.7, colorStr);\r\n                    gradient.addColorStop(1, darkenColor(colorStr, 20));\r\n\r\n                    ctx.fillStyle = gradient;\r\n                    ctx.beginPath();\r\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n\r\n                    ctx.strokeStyle = darkenColor(colorStr, 30);\r\n                    ctx.lineWidth = Math.max(2, r * 0.08);\r\n                    ctx.stroke();\r\n\r\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\r\n                    ctx.beginPath();\r\n                    ctx.arc(x - r * 0.25, y - r * 0.25, r * 0.25, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                } else {\r\n                    ctx.fillStyle = colorStr;\r\n                    ctx.beginPath();\r\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\r\n                    ctx.fill();\r\n                }\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n\r\n        renderMinimap();\r\n\r\n        // Update size display\r\n        const localId = getLocalClientId();\r\n        if (localId !== null) {\r\n            const cells = getPlayerCells(game, localId);\r\n            const totalRadius = cells.reduce((sum, c) => sum + c.get(modu.Sprite).radius, 0);\r\n            sizeDisplay.textContent = `Size: ${Math.floor(totalRadius)}`;\r\n        }\r\n    };\r\n}\r\n"],
  "mappings": "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",
  "names": ["modu", "game", "modu", "game", "physics", "modu", "WIDTH", "HEIGHT", "game", "cameraEntity", "getLocalClientId", "renderer", "canvas", "minimapCanvas", "sizeDisplay", "cam"]
}
