{
  "version": 3,
  "sources": ["cdn-global:modu-engine", "../src/game.ts", "../src/constants.ts", "../src/entities.ts", "../src/systems.ts", "../src/render.ts"],
  "sourcesContent": ["module.exports = window.Modu;", "import { dSqrt, dRandom } from 'modu-engine';\n/**\n * Cell Eater - Agar.io style multiplayer game\n *\n * Build auto-transforms: dSqrt() -> dSqrt(), dRandom() -> dRandom()\n */\n\nimport * as modu from 'modu-engine';\nimport { WORLD_WIDTH, WORLD_HEIGHT, FOOD_COUNT } from './constants';\nimport { defineEntities } from './entities';\nimport {\n    setupSystems,\n    setupCollisions,\n    spawnFood,\n    spawnCell,\n    getPlayerCells,\n    cellMergeFrame,\n} from './systems';\nimport { createRenderer } from './render';\n\n// Game state\nlet game: modu.Game;\nlet renderer: modu.Simple2DRenderer;\nlet physics: modu.Physics2DSystem;\nlet input: modu.InputPlugin;\nlet cameraSystem: modu.CameraSystem;\nlet cameraEntity: modu.Entity;\n\nlet canvas: HTMLCanvasElement;\nlet minimapCanvas: HTMLCanvasElement;\nlet sizeDisplay: HTMLElement;\nlet WIDTH: number;\nlet HEIGHT: number;\n\nlet mouseX: number;\nlet mouseY: number;\n\nfunction getLocalClientId(): number | null {\n    const clientId = game.localClientId;\n    if (!clientId || typeof clientId !== 'string') return null;\n    return game.internClientId(clientId);\n}\n\nfunction setupInput(): void {\n    mouseX = WIDTH / 2;\n    mouseY = HEIGHT / 2;\n\n    canvas.addEventListener('mousemove', (e) => {\n        const rect = canvas.getBoundingClientRect();\n        mouseX = e.clientX - rect.left;\n        mouseY = e.clientY - rect.top;\n    });\n\n    input.action('target', {\n        type: 'vector',\n        bindings: [() => {\n            // Convert screen coordinates to world coordinates using camera\n            const cam = cameraEntity.get(modu.Camera2D);\n            const worldX = (mouseX - WIDTH / 2) / cam.zoom + cam.x;\n            const worldY = (mouseY - HEIGHT / 2) / cam.zoom + cam.y;\n            return { x: worldX, y: worldY };\n        }]\n    });\n\n    input.action('split', {\n        type: 'button',\n        bindings: ['key: ']\n    });\n}\n\nexport function initGame(): void {\n    canvas = document.getElementById('game') as HTMLCanvasElement;\n    minimapCanvas = document.getElementById('minimap') as HTMLCanvasElement;\n    sizeDisplay = document.getElementById('size-display')!;\n    WIDTH = canvas.width;\n    HEIGHT = canvas.height;\n\n    game = modu.createGame();\n    renderer = game.addPlugin(modu.Simple2DRenderer, canvas);\n    physics = game.addPlugin(modu.Physics2DSystem, { gravity: { x: 0, y: 0 } });\n    input = game.addPlugin(modu.InputPlugin, canvas);\n    cameraSystem = game.addPlugin(modu.CameraSystem);\n\n    // Expose for debugging\n    (window as any).game = game;\n\n    defineEntities(game);\n    setupCollisions(game, physics);\n    setupSystems(game);\n\n    // Create camera entity and set it on renderer\n    cameraEntity = game.spawn('camera');\n    const cam = cameraEntity.get(modu.Camera2D);\n    cam.x = WORLD_WIDTH / 2;\n    cam.y = WORLD_HEIGHT / 2;\n    renderer.camera = cameraEntity;\n\n    setupInput();\n\n    renderer.render = createRenderer(\n        game,\n        renderer,\n        cameraEntity,\n        canvas,\n        minimapCanvas,\n        sizeDisplay,\n        getLocalClientId\n    );\n\n    game.connect('cell-eater-ecs', {\n        onRoomCreate() {\n            console.log('[cell-eater] onRoomCreate');\n            for (let i = 0; i < FOOD_COUNT; i++) spawnFood(game);\n        },\n        onConnect(clientId: string) {\n            console.log('[cell-eater] onConnect:', clientId);\n            spawnCell(game, clientId);\n\n            if (clientId === game.localClientId) {\n                const player = game.getEntityByClientId(clientId);\n                if (player) {\n                    const t = player.get(modu.Transform2D);\n                    const cam = cameraEntity.get(modu.Camera2D);\n                    cam.x = t.x;\n                    cam.y = t.y;\n                }\n            }\n        },\n        onDisconnect(clientId: string) {\n            console.log('[cell-eater] onDisconnect:', clientId);\n            const internedId = game.internClientId(clientId);\n            for (const cell of getPlayerCells(game, internedId)) {\n                cell.destroy();\n                cellMergeFrame.delete(cell.id);\n            }\n        }\n    });\n\n    modu.enableDebugUI(game);\n}\n\n// Auto-init when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initGame);\n} else {\n    initGame();\n}\n", "/**\n * Cell Eater - Game Constants\n */\n\n// World dimensions\nexport const WORLD_WIDTH = 6000;\nexport const WORLD_HEIGHT = 6000;\n\n// Zoom settings\nexport const BASE_ZOOM = 1.0;\nexport const MIN_ZOOM = 0.35;\nexport const ZOOM_SCALE_FACTOR = 0.004;\n\n// Movement\nexport const SPEED = 400;\n\n// Cell sizing\nexport const INITIAL_RADIUS = 20;\nexport const MAX_RADIUS = 200;\n\n// Eating mechanics\nexport const EAT_RATIO = 1.2;\nexport const FOOD_GROW = 0.05;\nexport const PLAYER_GROW = 0.3;\n\n// Food spawning\nexport const FOOD_COUNT = 800;\nexport const MAX_FOOD = 1600;\nexport const FOOD_SPAWN_CHANCE = 0.15;\n\n// Split mechanics\nexport const MIN_SPLIT_RADIUS = 15;\nexport const SPLIT_VELOCITY = 400;\nexport const SPLIT_CONTROL_DELAY = 30;\nexport const MAX_CELLS_PER_PLAYER = 16;\nexport const MERGE_DELAY_FRAMES = 600;\n\n// Color palette\nexport const COLORS = [\n    '#ff6b6b', '#ff8e72', '#ffa94d', '#ffd43b', '#a9e34b', '#69db7c',\n    '#38d9a9', '#3bc9db', '#4dabf7', '#748ffc', '#9775fa', '#da77f2',\n    '#f783ac', '#e64980', '#d6336c', '#c2255c', '#ff4500', '#32cd32',\n    '#1e90ff', '#ff1493', '#00ced1', '#ffa500', '#9400d3', '#00ff7f'\n];\n", "/**\n * Cell Eater - Entity Definitions\n */\n\nimport * as modu from 'modu-engine';\nimport { INITIAL_RADIUS } from './constants';\n\nexport function defineEntities(game: modu.Game): void {\n    game.defineEntity('cell')\n        .with(modu.Transform2D)\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, layer: 1 })\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: INITIAL_RADIUS, bodyType: modu.BODY_KINEMATIC })\n        .with(modu.Player)\n        .register();\n\n    game.defineEntity('food')\n        .with(modu.Transform2D)\n        .with(modu.Sprite, { shape: modu.SHAPE_CIRCLE, radius: 8, layer: 0 })\n        .with(modu.Body2D, { shapeType: modu.SHAPE_CIRCLE, radius: 8, bodyType: modu.BODY_STATIC })\n        .register();\n\n    // Camera entity - client-only (sync: false is built into Camera2D component)\n    game.defineEntity('camera')\n        .with(modu.Camera2D, { smoothing: 0.15 })\n        .register();\n}\n", "import { dSqrt, dRandom } from 'modu-engine';\n/**\n * Cell Eater - Game Systems\n */\n\nimport * as modu from 'modu-engine';\nimport { SpawnCellOptions } from './types';\nimport {\n    WORLD_WIDTH,\n    WORLD_HEIGHT,\n    SPEED,\n    INITIAL_RADIUS,\n    MAX_RADIUS,\n    EAT_RATIO,\n    FOOD_GROW,\n    PLAYER_GROW,\n    MAX_FOOD,\n    FOOD_SPAWN_CHANCE,\n    MIN_SPLIT_RADIUS,\n    SPLIT_VELOCITY,\n    SPLIT_CONTROL_DELAY,\n    MAX_CELLS_PER_PLAYER,\n    MERGE_DELAY_FRAMES,\n    COLORS,\n} from './constants';\n\n// Track merge eligibility frame for each cell\nexport const cellMergeFrame = new Map<number, number>();\nexport const cellSplitFrame = new Map<number, number>();\n\n// Helper functions\nfunction getClientIdStr(game: modu.Game, numericId: number): string {\n    return game.getClientIdString(numericId) || '';\n}\n\nfunction compareStrings(a: string, b: string): number {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n}\n\nexport function getPlayerCells(game: modu.Game, clientId: number): modu.Entity[] {\n    const cells: modu.Entity[] = [];\n    for (const cell of game.query('cell')) {\n        if (cell.get(modu.Player).clientId === clientId && !cell.destroyed) {\n            cells.push(cell);\n        }\n    }\n    return cells;\n}\n\nexport function spawnFood(game: modu.Game): void {\n    const colorStr = COLORS[(dRandom() * COLORS.length) | 0];\n    const color = game.internString('color', colorStr);\n    game.spawn('food', {\n        x: 50 + (dRandom() * (WORLD_WIDTH - 100)) | 0,\n        y: 50 + (dRandom() * (WORLD_HEIGHT - 100)) | 0,\n        color\n    });\n}\n\nexport function spawnCell(game: modu.Game, clientId: string, options: SpawnCellOptions = {}): modu.Entity {\n    const colorStr = options.color || COLORS[(dRandom() * COLORS.length) | 0];\n    const color = game.internString('color', colorStr);\n    const radius = options.radius || INITIAL_RADIUS;\n\n    const entity = game.spawn('cell', {\n        x: options.x ?? (100 + (dRandom() * (WORLD_WIDTH - 200)) | 0),\n        y: options.y ?? (100 + (dRandom() * (WORLD_HEIGHT - 200)) | 0),\n        clientId,\n        color\n    });\n\n    if (options.radius) {\n        const sprite = entity.get(modu.Sprite);\n        const body = entity.get(modu.Body2D);\n        sprite.radius = radius;\n        body.radius = radius;\n    }\n\n    if (options.vx !== undefined || options.vy !== undefined) {\n        const body = entity.get(modu.Body2D);\n        body.vx = options.vx || 0;\n        body.vy = options.vy || 0;\n    }\n\n    return entity;\n}\n\nexport function setupSystems(game: modu.Game): void {\n    // Movement system with integrated repulsion\n    game.addSystem(() => {\n        const playerCells = new Map<number, modu.Entity[]>();\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\n\n        for (const cell of allCells) {\n            if (cell.destroyed) continue;\n            const cid = cell.get(modu.Player).clientId;\n            if (cid === undefined || cid === null) continue;\n            if (!playerCells.has(cid)) playerCells.set(cid, []);\n            playerCells.get(cid)!.push(cell);\n        }\n\n        // DEBUG: Log cell counts\n        if (game.world.frame % 60 === 0) {\n            for (const [cid, cells] of playerCells) {\n                if (cells.length > 1) console.log(`[SPLIT] cid=${cid} cells=${cells.length}`);\n            }\n        }\n\n        const repulsion = new Map<number, { vx: number; vy: number }>();\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\n        );\n\n        for (const [, siblings] of sortedPlayers) {\n            for (const cell of siblings) {\n                repulsion.set(cell.id, { vx: 0, vy: 0 });\n            }\n\n            if (siblings.length < 2) continue;\n\n            for (let i = 0; i < siblings.length; i++) {\n                const cellA = siblings[i];\n                const tA = cellA.get(modu.Transform2D);\n                const sA = cellA.get(modu.Sprite);\n\n                for (let j = i + 1; j < siblings.length; j++) {\n                    const cellB = siblings[j];\n                    const tB = cellB.get(modu.Transform2D);\n                    const sB = cellB.get(modu.Sprite);\n\n                    const dx = tA.x - tB.x;\n                    const dy = tA.y - tB.y;\n                    const distSq = dx * dx + dy * dy;\n                    const minDist = sA.radius + sB.radius;\n                    const minDistSq = minDist * minDist;\n\n                    if (distSq < minDistSq && distSq > 1) {\n                        const dist = dSqrt(distSq) || 1;\n                        const overlap = minDist - dist;\n                        const pushForce = (overlap * 0.3) + 1;\n                        const nx = dx / dist;\n                        const ny = dy / dist;\n\n                        const repA = repulsion.get(cellA.id)!;\n                        const repB = repulsion.get(cellB.id)!;\n                        repA.vx += nx * pushForce;\n                        repA.vy += ny * pushForce;\n                        repB.vx -= nx * pushForce;\n                        repB.vy -= ny * pushForce;\n                    }\n                }\n            }\n        }\n\n        for (const [clientId, cells] of sortedPlayers) {\n            const playerInput = game.world.getInput(clientId);\n            for (const cell of cells) {\n                const sprite = cell.get(modu.Sprite);\n                const transform = cell.get(modu.Transform2D);\n                const body = cell.get(modu.Body2D);\n\n                let vx = 0, vy = 0;\n\n                if (playerInput?.target) {\n                    const dx = playerInput.target.x - transform.x;\n                    const dy = playerInput.target.y - transform.y;\n                    const distSq = dx * dx + dy * dy;\n                    const dist = dSqrt(distSq) || 1;\n\n                    const stopDist = sprite.radius * 0.2;\n                    if (dist > stopDist) {\n                        vx = (dx / dist) * SPEED;\n                        vy = (dy / dist) * SPEED;\n                    }\n                }\n\n                const rep = repulsion.get(cell.id);\n                if (rep) {\n                    vx += rep.vx;\n                    vy += rep.vy;\n                }\n\n                // Don't override velocity for recently split cells\n                const splitFrame = cellSplitFrame.get(cell.id) || 0;\n                const framesSinceSplit = game.world.frame - splitFrame;\n                if (framesSinceSplit > SPLIT_CONTROL_DELAY) {\n                    body.vx = vx;\n                    body.vy = vy;\n                }\n\n                const r = sprite.radius;\n                transform.x = Math.max(r, Math.min(WORLD_WIDTH - r, transform.x));\n                transform.y = Math.max(r, Math.min(WORLD_HEIGHT - r, transform.y));\n            }\n        }\n    }, { phase: 'update' });\n\n    // Food spawning system\n    game.addSystem(() => {\n        const shouldSpawn = dRandom() < FOOD_SPAWN_CHANCE;\n        if (shouldSpawn && game.getEntitiesByType('food').length < MAX_FOOD) {\n            spawnFood(game);\n        }\n    }, { phase: 'update' });\n\n    // Split system\n    game.addSystem(() => {\n        const playerCells = new Map<number, modu.Entity[]>();\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\n\n        for (const cell of allCells) {\n            if (cell.destroyed) continue;\n            const clientId = cell.get(modu.Player).clientId;\n            if (clientId === undefined || clientId === null) continue;\n            if (!playerCells.has(clientId)) playerCells.set(clientId, []);\n            playerCells.get(clientId)!.push(cell);\n        }\n\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\n        );\n\n        for (const [clientId, cells] of sortedPlayers) {\n            const playerInput = game.world.getInput(clientId);\n\n            if (!playerInput?.split || !playerInput?.target) continue;\n            if (cells.length >= MAX_CELLS_PER_PLAYER) continue;\n\n            const cellsToSplit = cells\n                .filter(c => c.get(modu.Sprite).radius >= MIN_SPLIT_RADIUS)\n                .slice(0, MAX_CELLS_PER_PLAYER - cells.length);\n\n            for (const cell of cellsToSplit) {\n                const transform = cell.get(modu.Transform2D);\n                const sprite = cell.get(modu.Sprite);\n                const body = cell.get(modu.Body2D);\n                const colorStr = game.getString('color', sprite.color);\n\n                const dx = playerInput.target.x - transform.x;\n                const dy = playerInput.target.y - transform.y;\n                const dist = dSqrt(dx * dx + dy * dy);\n                const dirX = dist > 0 ? dx / dist : 0;\n                const dirY = dist > 0 ? dy / dist : 1;\n\n                const newRadius = sprite.radius / Math.SQRT2;\n\n                sprite.radius = newRadius;\n                body.radius = newRadius;\n\n                const clientIdStr = game.getClientIdString(clientId);\n                if (!clientIdStr) continue;\n\n                const newCell = spawnCell(game, clientIdStr, {\n                    x: transform.x + dirX * newRadius * 2,\n                    y: transform.y + dirY * newRadius * 2,\n                    radius: newRadius,\n                    color: colorStr,\n                    vx: dirX * SPLIT_VELOCITY,\n                    vy: dirY * SPLIT_VELOCITY\n                });\n\n                const mergeFrame = game.world.frame + MERGE_DELAY_FRAMES;\n                cellMergeFrame.set(cell.id, mergeFrame);\n                cellSplitFrame.set(cell.id, game.world.frame);\n                cellMergeFrame.set(newCell.id, mergeFrame);\n                cellSplitFrame.set(newCell.id, game.world.frame);\n            }\n        }\n    }, { phase: 'update' });\n\n    // Merge system\n    game.addSystem(() => {\n        const currentFrame = game.world.frame;\n        const playerCells = new Map<number, modu.Entity[]>();\n        const allCells = [...game.query('cell')].sort((a, b) => a.id - b.id);\n\n        for (const cell of allCells) {\n            if (cell.destroyed) continue;\n            const clientId = cell.get(modu.Player).clientId;\n            if (clientId === undefined || clientId === null) continue;\n            if (!playerCells.has(clientId)) playerCells.set(clientId, []);\n            playerCells.get(clientId)!.push(cell);\n        }\n\n        const sortedPlayers = [...playerCells.entries()].sort((a, b) =>\n            compareStrings(getClientIdStr(game, a[0]), getClientIdStr(game, b[0]))\n        );\n\n        for (const [, cells] of sortedPlayers) {\n            if (cells.length < 2) continue;\n\n            cells.sort((a, b) => {\n                const radiusDiff = b.get(modu.Sprite).radius - a.get(modu.Sprite).radius;\n                return radiusDiff !== 0 ? radiusDiff : a.id - b.id;\n            });\n\n            for (let i = 0; i < cells.length; i++) {\n                const cellA = cells[i];\n                if (cellA.destroyed) continue;\n\n                const tA = cellA.get(modu.Transform2D);\n                const sA = cellA.get(modu.Sprite);\n\n                for (let j = i + 1; j < cells.length; j++) {\n                    const cellB = cells[j];\n                    if (cellB.destroyed) continue;\n\n                    const mergeFrameA = cellMergeFrame.get(cellA.id) || 0;\n                    const mergeFrameB = cellMergeFrame.get(cellB.id) || 0;\n                    if (currentFrame < mergeFrameA || currentFrame < mergeFrameB) continue;\n\n                    const tB = cellB.get(modu.Transform2D);\n                    const sB = cellB.get(modu.Sprite);\n\n                    const dx = tA.x - tB.x;\n                    const dy = tA.y - tB.y;\n                    const dist = dSqrt(dx * dx + dy * dy);\n                    const mergeThreshold = (sA.radius + sB.radius) * 0.5;\n\n                    if (dist < mergeThreshold) {\n                        const areaA = sA.radius * sA.radius;\n                        const areaB = sB.radius * sB.radius;\n                        const newRadius = Math.min(dSqrt(areaA + areaB), MAX_RADIUS);\n\n                        sA.radius = newRadius;\n                        cellA.get(modu.Body2D).radius = newRadius;\n                        cellB.destroy();\n                        cellMergeFrame.delete(cellB.id);\n                    }\n                }\n            }\n        }\n    }, { phase: 'update' });\n}\n\nexport function setupCollisions(game: modu.Game, physics: modu.Physics2DSystem): void {\n    // Cell eats food\n    physics.onCollision('cell', 'food', (cell, food) => {\n        if (food.destroyed) return;\n        const sprite = cell.get(modu.Sprite);\n        const foodSprite = food.get(modu.Sprite);\n        sprite.radius = Math.min(sprite.radius + foodSprite.radius * FOOD_GROW, MAX_RADIUS);\n        cell.get(modu.Body2D).radius = sprite.radius;\n        food.destroy();\n    });\n\n    // Cell eats smaller cell (different players only)\n    physics.onCollision('cell', 'cell', (cellA, cellB) => {\n        if (cellA.get(modu.Player).clientId === cellB.get(modu.Player).clientId) return;\n\n        const eaterSprite = cellA.get(modu.Sprite);\n        const preySprite = cellB.get(modu.Sprite);\n        if (eaterSprite.radius > preySprite.radius * EAT_RATIO) {\n            eaterSprite.radius = Math.min(eaterSprite.radius + preySprite.radius * PLAYER_GROW, MAX_RADIUS);\n            cellA.get(modu.Body2D).radius = eaterSprite.radius;\n            cellB.destroy();\n            cellMergeFrame.delete(cellB.id);\n        }\n    });\n}\n", "import { dSqrt } from 'modu-engine';\n/**\n * Cell Eater - Rendering & Camera\n */\n\nimport * as modu from 'modu-engine';\nimport { getPlayerCells } from './systems';\nimport {\n    WORLD_WIDTH,\n    WORLD_HEIGHT,\n    BASE_ZOOM,\n    MIN_ZOOM,\n    ZOOM_SCALE_FACTOR,\n    INITIAL_RADIUS,\n} from './constants';\n\nexport function lightenColor(hex: string, percent: number): string {\n    const num = parseInt(hex.slice(1), 16);\n    const r = Math.min(255, (num >> 16) + percent);\n    const g = Math.min(255, ((num >> 8) & 0x00FF) + percent);\n    const b = Math.min(255, (num & 0x0000FF) + percent);\n    return `rgb(${r},${g},${b})`;\n}\n\nexport function darkenColor(hex: string, percent: number): string {\n    const num = parseInt(hex.slice(1), 16);\n    const r = Math.max(0, (num >> 16) - percent);\n    const g = Math.max(0, ((num >> 8) & 0x00FF) - percent);\n    const b = Math.max(0, (num & 0x0000FF) - percent);\n    return `rgb(${r},${g},${b})`;\n}\n\nexport function worldToScreen(\n    worldX: number,\n    worldY: number,\n    camX: number,\n    camY: number,\n    camZoom: number,\n    WIDTH: number,\n    HEIGHT: number\n): { x: number; y: number } {\n    return {\n        x: (worldX - camX) * camZoom + WIDTH / 2,\n        y: (worldY - camY) * camZoom + HEIGHT / 2\n    };\n}\n\nexport function updateCamera(\n    game: modu.Game,\n    cameraEntity: modu.Entity,\n    getLocalClientId: () => number | null\n): void {\n    const localId = getLocalClientId();\n    if (localId === null) return;\n\n    const cells = getPlayerCells(game, localId);\n    if (cells.length === 0) return;\n\n    const camera = cameraEntity.get(modu.Camera2D);\n\n    let totalArea = 0;\n    let centerX = 0;\n    let centerY = 0;\n    let totalRadius = 0;\n\n    for (const cell of cells) {\n        const transform = cell.get(modu.Transform2D);\n        const sprite = cell.get(modu.Sprite);\n        const area = sprite.radius * sprite.radius;\n\n        centerX += transform.x * area;\n        centerY += transform.y * area;\n        totalArea += area;\n        totalRadius += sprite.radius;\n    }\n\n    if (totalArea > 0) {\n        centerX /= totalArea;\n        centerY /= totalArea;\n\n        camera.x += (centerX - camera.x) * camera.smoothing;\n        camera.y += (centerY - camera.y) * camera.smoothing;\n\n        const avgRadius = totalRadius / cells.length;\n        camera.targetZoom = Math.max(MIN_ZOOM, BASE_ZOOM - (avgRadius - INITIAL_RADIUS) * ZOOM_SCALE_FACTOR);\n\n        if (cells.length > 1) {\n            let maxDist = 0;\n            for (const cell of cells) {\n                const t = cell.get(modu.Transform2D);\n                const dist = dSqrt((t.x - centerX) ** 2 + (t.y - centerY) ** 2);\n                maxDist = Math.max(maxDist, dist);\n            }\n            const spreadZoom = Math.max(0.3, 1 - maxDist / 800);\n            camera.targetZoom = Math.min(camera.targetZoom, spreadZoom);\n        }\n\n        camera.zoom += (camera.targetZoom - camera.zoom) * camera.smoothing;\n    }\n}\n\nexport function createRenderer(\n    game: modu.Game,\n    renderer: modu.Simple2DRenderer,\n    cameraEntity: modu.Entity,\n    canvas: HTMLCanvasElement,\n    minimapCanvas: HTMLCanvasElement,\n    sizeDisplay: HTMLElement,\n    getLocalClientId: () => number | null\n): () => void {\n    const ctx = renderer.context;\n    const minimapCtx = minimapCanvas.getContext('2d')!;\n    const WIDTH = canvas.width;\n    const HEIGHT = canvas.height;\n\n    function renderMinimap(): void {\n        const camera = cameraEntity.get(modu.Camera2D);\n        const mmW = minimapCanvas.width;\n        const mmH = minimapCanvas.height;\n        const scaleX = mmW / WORLD_WIDTH;\n        const scaleY = mmH / WORLD_HEIGHT;\n\n        minimapCtx.fillStyle = 'rgba(17, 17, 17, 0.9)';\n        minimapCtx.fillRect(0, 0, mmW, mmH);\n\n        minimapCtx.strokeStyle = '#333';\n        minimapCtx.lineWidth = 1;\n        minimapCtx.strokeRect(0, 0, mmW, mmH);\n\n        for (const entity of game.getAllEntities()) {\n            if (entity.destroyed) continue;\n            try {\n                const sprite = entity.get(modu.Sprite);\n                if (!sprite || !sprite.visible) continue;\n\n                const transform = entity.get(modu.Transform2D);\n                const x = transform.x * scaleX;\n                const y = transform.y * scaleY;\n\n                const isFood = sprite.layer === 0;\n                const radius = isFood ? 1 : Math.max(3, sprite.radius * scaleX * 1.5);\n\n                const colorStr = game.getString('color', sprite.color) || '#fff';\n                minimapCtx.fillStyle = isFood ? 'rgba(255,255,255,0.3)' : colorStr;\n                minimapCtx.beginPath();\n                minimapCtx.arc(x, y, radius, 0, Math.PI * 2);\n                minimapCtx.fill();\n            } catch {}\n        }\n\n        const viewLeft = (camera.x - WIDTH / 2 / camera.zoom) * scaleX;\n        const viewTop = (camera.y - HEIGHT / 2 / camera.zoom) * scaleY;\n        const viewWidth = (WIDTH / camera.zoom) * scaleX;\n        const viewHeight = (HEIGHT / camera.zoom) * scaleY;\n\n        minimapCtx.strokeStyle = '#fff';\n        minimapCtx.lineWidth = 1;\n        minimapCtx.strokeRect(viewLeft, viewTop, viewWidth, viewHeight);\n\n        const localId = getLocalClientId();\n        if (localId !== null) {\n            const cells = getPlayerCells(game, localId);\n            for (const cell of cells) {\n                if (cell.destroyed) continue;\n                const transform = cell.get(modu.Transform2D);\n                const x = transform.x * scaleX;\n                const y = transform.y * scaleY;\n\n                minimapCtx.strokeStyle = '#fff';\n                minimapCtx.lineWidth = 2;\n                minimapCtx.beginPath();\n                minimapCtx.arc(x, y, 5, 0, Math.PI * 2);\n                minimapCtx.stroke();\n            }\n        }\n    }\n\n    return function renderWithCamera(): void {\n        const alpha = game.getRenderAlpha();\n        const camera = cameraEntity.get(modu.Camera2D);\n\n        updateCamera(game, cameraEntity, getLocalClientId);\n\n        let camX = camera.x, camY = camera.y;\n        const localId = getLocalClientId();\n        if (localId !== null) {\n            const cells = getPlayerCells(game, localId);\n            if (cells.length > 0) {\n                let totalArea = 0;\n                let centerX = 0;\n                let centerY = 0;\n\n                for (const cell of cells) {\n                    if (cell.destroyed || !cell.render) continue;\n                    cell.interpolate(alpha);\n                    const sprite = cell.get(modu.Sprite);\n                    const area = sprite.radius * sprite.radius;\n                    centerX += cell.render.interpX * area;\n                    centerY += cell.render.interpY * area;\n                    totalArea += area;\n                }\n\n                if (totalArea > 0) {\n                    camX = centerX / totalArea;\n                    camY = centerY / totalArea;\n                }\n            }\n        }\n\n        // Clear canvas\n        ctx.fillStyle = '#f2f2f2';\n        ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n        ctx.save();\n        ctx.translate(WIDTH / 2, HEIGHT / 2);\n        ctx.scale(camera.zoom, camera.zoom);\n        ctx.translate(-camX, -camY);\n\n        // Draw grid\n        ctx.strokeStyle = '#e0e0e0';\n        ctx.lineWidth = 1 / camera.zoom;\n        const gridSize = 100;\n        const startX = Math.floor((camX - WIDTH / 2 / camera.zoom) / gridSize) * gridSize;\n        const startY = Math.floor((camY - HEIGHT / 2 / camera.zoom) / gridSize) * gridSize;\n        const endX = camX + WIDTH / 2 / camera.zoom;\n        const endY = camY + HEIGHT / 2 / camera.zoom;\n\n        for (let x = startX; x <= endX; x += gridSize) {\n            if (x >= 0 && x <= WORLD_WIDTH) {\n                ctx.beginPath();\n                ctx.moveTo(x, Math.max(0, startY));\n                ctx.lineTo(x, Math.min(WORLD_HEIGHT, endY));\n                ctx.stroke();\n            }\n        }\n        for (let y = startY; y <= endY; y += gridSize) {\n            if (y >= 0 && y <= WORLD_HEIGHT) {\n                ctx.beginPath();\n                ctx.moveTo(Math.max(0, startX), y);\n                ctx.lineTo(Math.min(WORLD_WIDTH, endX), y);\n                ctx.stroke();\n            }\n        }\n\n        // Draw world boundary\n        ctx.strokeStyle = '#ccc';\n        ctx.lineWidth = 4 / camera.zoom;\n        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);\n\n        // Collect and sort entities by layer\n        const entities: { entity: modu.Entity; layer: number }[] = [];\n        for (const entity of game.getAllEntities()) {\n            if (entity.destroyed) continue;\n            try {\n                const sprite = entity.get(modu.Sprite);\n                if (sprite && sprite.visible) {\n                    entity.interpolate(alpha);\n                    entities.push({ entity, layer: sprite.layer });\n                }\n            } catch {}\n        }\n        entities.sort((a, b) => a.layer - b.layer);\n\n        // Draw entities\n        for (const { entity } of entities) {\n            const sprite = entity.get(modu.Sprite);\n            const x = entity.render.interpX + sprite.offsetX;\n            const y = entity.render.interpY + sprite.offsetY;\n\n            const screenPos = worldToScreen(x, y, camX, camY, camera.zoom, WIDTH, HEIGHT);\n            const screenRadius = sprite.radius * camera.zoom;\n            if (screenPos.x + screenRadius < 0 || screenPos.x - screenRadius > WIDTH ||\n                screenPos.y + screenRadius < 0 || screenPos.y - screenRadius > HEIGHT) {\n                continue;\n            }\n\n            const colorStr = game.getString('color', sprite.color) || '#fff';\n\n            if (sprite.shape === modu.SHAPE_CIRCLE) {\n                const r = sprite.radius;\n                const isCell = sprite.layer === 1;\n\n                if (isCell && r > 10) {\n                    const gradient = ctx.createRadialGradient(x - r * 0.3, y - r * 0.3, 0, x, y, r);\n                    gradient.addColorStop(0, lightenColor(colorStr, 40));\n                    gradient.addColorStop(0.7, colorStr);\n                    gradient.addColorStop(1, darkenColor(colorStr, 20));\n\n                    ctx.fillStyle = gradient;\n                    ctx.beginPath();\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\n                    ctx.fill();\n\n                    ctx.strokeStyle = darkenColor(colorStr, 30);\n                    ctx.lineWidth = Math.max(2, r * 0.08);\n                    ctx.stroke();\n\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';\n                    ctx.beginPath();\n                    ctx.arc(x - r * 0.25, y - r * 0.25, r * 0.25, 0, Math.PI * 2);\n                    ctx.fill();\n                } else {\n                    ctx.fillStyle = colorStr;\n                    ctx.beginPath();\n                    ctx.arc(x, y, r, 0, Math.PI * 2);\n                    ctx.fill();\n                }\n            }\n        }\n\n        ctx.restore();\n\n        renderMinimap();\n\n        // Update size display\n        if (localId !== null) {\n            const cells = getPlayerCells(game, localId);\n            const totalRadius = cells.reduce((sum, c) => sum + c.get(modu.Sprite).radius, 0);\n            sizeDisplay.textContent = `Size: ${Math.floor(totalRadius)}`;\n        }\n    };\n}\n"],
  "mappings": "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",
  "names": ["modu", "game", "modu", "game", "physics", "import_modu_engine", "modu", "WIDTH", "HEIGHT", "game", "cameraEntity", "getLocalClientId", "renderer", "canvas", "minimapCanvas", "sizeDisplay", "cam"]
}
